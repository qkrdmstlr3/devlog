---
id: 14
title: 201 상태코드는 어디로 갔을까?
date: '2022-05-29'
category: develop
summary: 졸업프로젝트 api를 설계하며 201코드에 대해서 탐구해보았습니다
---

## 질의

**졸업프로젝트**를 하면서 클라이언트와 서버가 주고받을 api문서를 작성했을 때 발생한 일이다. [MDN 상태코드 문서](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)를 보면 `200 OK`는 요청에 성공했음을 나타내는 상태코드이고, `201 Created`는 요청이 성공적으로 처리되었고 리소스가 생성되었음을 나타내는 성공 상태 응답 코드라고 나와있으며 201 상태코드는 응답헤드에 새로 생성된 리소스에 대한 URL을 나타내는 [location정보](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location)가 들어있다고 한다.

생성과 관련된 api문서를 작성하는 도중 이에 관해서 팀 내 논의가 이루어졌는데, **상태 코드로 201을 사용하는 경우 location에는 어떤 값을 담아야하는가**라는 질문이 쟁점으로 다루어졌다. 이에 대한 답을 찾기 위해서 리소스란 어떤 것인가?부터 만약 생성된 리소스가 새로운 주소를 가지는 리소스가 아닌 기존 리소스에 추가되는 리소스(ex. 게시글에 추가되는 댓글)라면 location의 주소는 게시글의 주소가 되는 것이 맞는가? 까지 이런저런 질문들을 주고받으며 논의했다. 그 과정에서 실제 사례를 찾아보고자 크롬 개발자도구의 네트워크 탭으로 현재 운영중인 웹페이지들을 분석하였는데 결과는 아래와 같다. 우리의 주요 분석 대상은 `깃허브`로, 여러 테스트를 쉽게 해볼 수 있으며 왠지 **깃허브**라는 이름에서부터 믿음이 들었기 때문이다.

가장 먼저 해본 것은 issue에서 comment를 생성해보는 것이었다. 생성해보기 전에 우리는 "응답 결과로 201이 올 것이며 location정보로 해당 issue의 주소가 담길 것이다"라고 예측했으나

![create-comment](/develop/images/status-code/create-comment.png)

보기좋게 틀려버렸다~ 상태 코드로 `200`을 돌려주는 것이잖는가.

그러면 url의 변동이 일어나는 issue를 생성하면 어떤 일이 일어날까?

![create-issue-one](/develop/images/status-code/create-issue-one.png)
![create-issue-two](/develop/images/status-code/create-issue-two.png)

이 경우에는 리다이렉트를 의미하는 `302`를 반환하면서 get요청으로 만들어진 issue를 가져오는(`200`) 것을 확인할 수 있었다. 302를 반환하는 응답헤더에는 location값으로 새로 만들어진 issue의 주소가 들어있었다.

![create-label](/develop/images/status-code/create-label.png)

이 외에도 label의 생성은 이슈를 생성했을 때와 동일하게 `200`을 받았으며

![create-milestone-one](/develop/images/status-code/create-milestone-one.png)
![create-milestone-two](/develop/images/status-code/create-milestone-two.png)

![create-repo-one](/develop/images/status-code/create-repo-one.png)
![create-repo-two](/develop/images/status-code/create-repo-two.png)

milestone과 repository는 `302/200`을 받음을 볼 수 있었다.

201을 찾고자 네이버 카페, 티스토리, 오늘의 집 등 몇몇 웹사이트에서 실험을 해보았지만 모두 `302/200`혹은 `200`을 사용하고 있었으며 `201`을 사용하는 경우는 찾을 수 없었다.
(댓글 생성시에 페이지를 현재 게시글로 리다이렉트(302)하면서 location으로는 게시글의 주소를 주는 경우도 있었다)

이쯤되니 우리의 의문은 `201의 location으로 무엇을 주어야하나?`에서 `201은 대체 어디로 갔나?`로 바뀌었다. 도대체 201은 어디서 쓸까? 여태껏 자원을 새로 생성할 경우에는 201을 사용한다고 배웠는데(들었는데) 우리는 어떻게 해야할까? 등의 문제를 두고 다시 토론이 이루어졌다.

그 결론은 `에라이 모르겠다`였다. 4학년 3명이 가진 지식들로는 열심히 짱구를 굴려봤자 "이래서 이렇지 않을까? 저래서 저렇지 않을까?"라는 식의 뇌피셜만 난무했고, 찝찝함만 남겨둔채 모두가 납득할만한 답은 나오지 않았기 때문이다.

## 응답

구글링으로는 깔끔히 해소되는 답변을 얻을 수 없어, 스택오버플로우등에 궁금한 점을 정리해 물어보았고, 결과로 얻어진 답변을 요약하면 아래와 같다.

"
일단 공통적으로 얻어진 답은 **클라이언트와 서버간에 협의만하면 상관없다**라는 것이었다. 성공 상태코드를 200, 201, 204등으로 다양하게 주면 프론트에서 대처하는 방식이 너무 다양해지기 때문에 모두 200으로 처리하는 경우가 많다는 것이다. 심지어 응답이 실패했을 경우에도 200으로 약속해서 처리하는 경우도 있다고 한다,,,

그리고 201과 302를 먼저 비교하자면, 201과 302는 목적과 처리방법에 있어 차이가 있다. `201` 같은 경우는 location으로 생성된 리소스를 지정해주거나 완성된 리소스를 body로 되돌릴 수 있고, `3XX`같은 경우는 location을 다시 GET으로 request한다는 것이다. 이 때 `201`은 완성된 리소스를 body로 돌리거나 리다이렉트하는 것 둘 다를 포함할 수 있고 클라이언트에서 판단할 여지를 준다는 점에서 `200 + 3XX` 와 같은 효과를 가진다. 그렇기에 간단한 처리시에는 `200 + 3XX`방식을 사용하고 별도 처리로 유도하는 등 복잡한 방법에는 `201`을 사용하는 것이 더 유리할 수 있다.

하지만 이전에는 `201`을 쓰지 않고도 `200`이나 `302`등으로 처리할 수 있는 부분이었기 때문에 개발 경력이 오래된 서비스일수록 안정성을 위해 새로이 도입하지 않았을 수 있다(IE지원을 생각해보자). 추가적으로 201상태코드를 쓰더라도 [location정보](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location)를 반드시 넣어줄 필요가 있는 것은 아니다.
"

말끔히 해소된 느낌은 아니지만 되게 답답했던 우리에게는 어느정도 납득이 가는 답변들이었고, 어떤 상황에서 무엇을 써야하는지에 대해서 어느정도 느낌은 받을 수 있었다.

## 결론

결론은 팀 내에서 협의만 하면 상관없다는 것 같다.

우리는 우리 프로젝트의 모체인 [FOSSLight](https://demo.fosslight.org/session/login)에서 사용하는 것처럼 단일 url내에서 여러가지 tab을 이용한 구조를 사용하고 있다. 따라서 location으로 redirect할 일은 없었고, 프론트와 백의 합의하에 생성 시 응답코드로 깃허브처럼 `200`을 사용하기로 결정하였다. 더불어 아직까지 팀명이 없었는데 `201 Created`를 우리 팀명으로 정하기도했다.

### 찾았다!

이전에 인프런에서 김영한님의 http강의를 들은적이 있어, 그곳에 문의한 결과 사용되는 곳이 있다는 답변을 받았다. 바로 깃허브의 Project인데 현재 베타버전으로 보인다

![create-project](/develop/images/status-code/create-project.png)

여기서 item을 생성하면 201코드를 돌려주는데, location은 존재하지 않는다. 깃허브는 왜 이 친구는 201로 상태코드를 반환하도록 설계했을까? ~~최근에 만들어진 기능들에는 201을 적용하나?~~

이전에 두 달간 인턴을 한 회사에서는 grpc를 써서 처음 배우는 개념을 익히느라 [grpc의 상태코드](https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto)에는 관심을 두지 않았다. 빨리 현업에 들어가서 실제로 개발되는 api문서에 `201`이 적혀있는지를 보고싶다.
